+++
title = "ShopifyのAPI呼び出しをSQSを使って並列処理する"
tags = ["SQS", "Shopify"]
date = "2021-06-13"
+++

ShopifyのAPI呼び出しには制限があって、その制限のされ方もいくつかある。
https://shopify.dev/concepts/about-apis/rate-limits

ShopifyにはPlusというプランがあってそれを使う場合はこの制限が緩和されるけど、ここではスタンダードのプランについて書く。
GraphQL APIにかかる制限はLeaky Bucketという仕組みで計算される。

何もAPIコールをしていなければ1000ポイントを上限としてAPIコールするたびにそこからコールにかかったポイントを差し引いてゆく。
引かれたポイントは1秒に50ポイントのスピードで回復する。
これがアプリ毎に、ストア毎にそれぞれ個別に計算される。

APIコールで何ポイント引かれるかはそのフィールドの数やタイプ、QueryかMutationsかといったパラメータによって変わってくる。
自分の場合はAPIコールしてみてそのレスポンスとして得られる消費コストの部分を確認するということしかしたことがないので、前もって消費ポイントを計算するというのをしたことがないが、めんどくさそうだけどやることはできるのだと思う。

ともかくこうした制限があるので、何千といった数の商品を一気に登録するだとか内容を変更するだとか、そういったことをしたいと思った時には時間がかかる。
上限を超えてAPIコールをした場合はAPIのレスポンスに`Throttled`というメッセージのエラーが乗ってくる。

で、ここまで書いておいてそれとはまた少し違う話なんだけど、このスロットリングが発生する以前の話としてそもそもレイテンシーがよくない。
感覚としてはパートナー向け開発用ダミーのストアでは1APIコールが1秒程度かかるという印象だし、有償のストアでも変わらないかもしかすると少しマシという程度だと思う。このレイテンシーの悪さは安定しているので意図的にそうしているのかなあと思う。

だから商品を1つ1つ処理するような小さめのコストのAPIコールをシーケンシャルにしている限り、上に書いたようなスロットリングが発生するような制限には達しないと思う。逆に大量の処理をするにはガッツリ時間がかかる。

APIによってはバッチ処理（ShopifyではBulk）が可能なものもあるので、そうしたものを利用する手はあるけれど、バッチ中の成功失敗の管理が面倒な気がして今の所自分は使ったことがない。なのでここでは1つ1つ処理する形でのAPIコールに限定した話となる。

APIコールは前述の通りレイテンシーがよくないので、利用可能なポイントをフルに利用して早めに処理を終わらせるにはシーケンシャルな呼び出しではなく、マルチスレッドのような方法でAPIコールのレスポンスを待たずに、別のAPIコールをするという仕組みをしたら良いということになる。

SQSを使えばLambdaが複数のインスタンスを起動して処理を進めてくれるので、これがちょうどShopifyのAPIコールに使えると考えた。

でやってみた結果を書いておきます。
これは今の所、開発者向けのストアで試した範囲の情報です。

[Githubのリポジトリ](https://github.com/suzukiken/cdk-sqs-shopify-api)

実際にそういうAPI呼び出しをするケースがあるかはおいといて

1.商品の登録
2.SKUで商品の検索をして在庫数IDを取得
3.在庫数を変更
4.在庫数を確認
5.商品を削除

と5つのAPI呼び出しを1回のLambda関数で行う。
この5つのAPI呼び出しは合計で46ポイントを消費する。

このLambda関数をSQSのコンシューマーとして登録して、そうしなくても良いが一応バッチサイズは1とした。

メッセージを重複して処理する可能性があると考えて処理が最後までできたらDynamoDBにメッセージIDを記録するようにして、処理する前に同じメッセージIDがないかDBを確認しもしあった場合は重複が発生したことがわかるように呼び出された回数を記録するようにした。

1回のLambda関数の実行にかかる時間は大体5秒なので、Lambdaの実行時間は10秒、キューのインビジブル時間は15秒、10回インビジブルになっても処理されなかったメッセージはデッドレターキューに移動するようにした。

この状態で500のメッセージをキューに投げ込む。

その結果はこんなものだった。いいところだけ書いてしまうとシーケンシャルな処理の10分の1の時間で処理が終わった。

* 1回の関数の実行にかかった時間は4.020から6.058秒とほぼ安定している（1APIコールに0.8秒ぐらいかかる）
* 全てのメッセージが正常に処理されてデッドレターキューには移動しなかった。
* 関数の実行時間の合計は約200分ほどなのでシーケンシャルに処理していたら3時間以上かかることになる
* 最初のメッセージの処理終了から最後のメッセージの処理終了までに約21分だったのでシーケンシャルな処理の10倍高速に処理された
* Shopify APIから帰ってきたエラーは全てがスロットリングのエラーで合計311回の発生した。
* スロットルは発生したがデッドレターにはならなかったことは、つまり最大10回の再試行のうちに処理が成功したことを意味する。
  （ちなみに再施行回数のところを1にするとデッドレターは発生する。）
* APIの呼び出し回数は2709回となった。これはもしスロットリングが発生しなければ2500回となるはずなので200回ほど無駄な呼び出しをしていることになる。
  （この無駄な呼び出しを止める方法としてはAPIコールのレスポンスで得られるcurrentlyAvailableを見て次のリクエストを取りやめる方法が考えられる）
* Lambdaインサイトで見るとLambdaの同時実行するはこの実験の最中に25となった。Lambda側のスロットルエラーは0件だった。

![img](/img/2021/06/lambda-insight-shopify-api.png)


今回もCloudWatch Logs Insightでエラーを確認した。

大抵シンタックスを忘れてしまうのでここにコピペ。
```
filter @message like /\[ERROR\]/
| fields @timestamp, @message
| sort by @timestamp desc
```
